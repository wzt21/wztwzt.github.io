内部协变量偏移（Internal Covariate Shift）是深度学习中的一个问题，它指的是在神经网络训练过程中，由于每一层的参数不断更新，导致网络各层的输入数据分布持续变化。这种分布的变化会使得网络层需要不断适应新的数据分布，从而降低学习速度，增加训练难度。

为了解决这个问题，批归一化（Batch Normalization，简称BN）技术被提出。BN通过对每个小批量数据进行归一化处理，使得数据分布更加稳定，减少了内部协变量偏移的影响。这不仅加快了模型的收敛速度，而且在一定程度上缓解了深层网络中的梯度消失问题，使得训练深层网络模型变得更加容易和稳定。

随机梯度下降（Stochastic gradient descent, SGD）
SGD 优化网络的参数 Θ，以最小化损失：
<img width="271" height="75" alt="Image" src="https://github.com/user-attachments/assets/bb75de8e-dd21-4f70-a82d-29c4fa14dcac" />
其中 x1…N 是训练数据集。使用 SGD，训练以步骤进行，在每一步中，我们考虑一个大小为 m 的 mini-batch x1…m。Mini-batch 用于通过计算
<img width="144" height="66" alt="Image" src="https://github.com/user-attachments/assets/d65e21cc-a067-4f0e-a819-28f9b8f7a954" />
来近似损失函数相对于参数的梯度。
与一次处理一个示例相比，使用 mini-batch 的示例有助于多种方式。首先，损失函数在 mini-batch 上的梯度是损失函数在训练集上的梯度的估计，其质量随着批量大小的增加而提高。其次，由于现代计算平台提供的并行性，对一批示例的计算比单个示例的 m 次计算更有效。

如果网络输入被白化（whitened）——即线性变换为零均值和单位方差，并且去相关——则网络训练收敛得更快。

然而，如果这些修改与优化步骤交错进行，那么梯度下降步骤可能会尝试更新参数，使其需要更新标准化，这会降低梯度步骤的效果。例如，考虑一个层，其输入为u，它加上一个学习到的偏置b，然后通过减去在整个训练数据上计算出的激活均值来对结果进行标准化：b x = x −E[x]，其中 x = u + b，X = {x1…N} 是x在整个训练集上的值集合，且 E[x] = 1/N Σi=1 xi。如果一个梯度下降步骤忽略了E[x]对b的依赖性，那么它将更新 b ←b + ∆b，其中 ∆b ∝−∂ℓ/∂b x。于是 u + (b + ∆b) −E[u + (b + ∆b)] = u + b −E[u + b]。因此，对b的更新和随后的标准化变化相结合，导致了层的输出没有变化，进而损失也没有变化。随着训练的继续，b将无限增长，而损失保持不变。

**Normailzation via Mini-Batch Statistics**
对于一个具有 d 维输入 x = (x(1) . . . x(d)) 的层，我们将每个维度标准化为：
<img width="331" height="111" alt="Image" src="https://github.com/user-attachments/assets/62bebbe9-8170-4107-95e6-84ae6d976270" />
‘’‘
“去相关”
在人工智能领域，“去相关”（decorrelation）通常是指减少或消除不同特征（变量）之间的统计相关性，以提升模型性能或满足某些算法的假设要求。具体来说：
目的：许多机器学习模型（如线性回归、朴素贝叶斯）假设输入特征相互独立。如果特征之间高度相关，会导致模型不稳定、泛化能力下降，或参数估计不准确。
常见方法：
主成分分析（PCA）：通过线性变换将原始特征映射到一组线性无关的主成分上，实现特征去相关和降维。
白化（whitening）：不仅去相关，还让各特征方差为1，常用于图像和信号预处理。
正交变换：如使用矩阵分解（如SVD）将特征空间正交化。
应用场景：图像处理、自然语言处理、语音识别等，尤其在高维数据中，去相关能有效提升模型训练效率和效果。
’‘’
仅仅标准化层的每个输入可能会改变层可以表示的内容。例如，标准化 sigmoid 的输入会将其约束到非线性函数的线性区域内。为了解决这个问题，我们确保插入到网络中的变换可以表示恒等变换。为此，我们为每个激活 x(k) 引入一对参数 γ(k), β(k)，它们缩放和偏移标准化值：
<img width="364" height="95" alt="Image" src="https://github.com/user-attachments/assets/6288b07b-301d-4ff3-944d-66c9a666c33f" />
这些参数与原始模型参数一起学习，并恢复了网络的表示能力。实际上，通过设置 γ(k) = √Var[x(k)] 和 β(k) = E[x(k)]，我们可以恢复原始激活

批零标准化变换：
<img width="295" height="73" alt="Image" src="https://github.com/user-attachments/assets/927a099f-9ae6-48b0-968f-5ce3943989a2" />

<img width="725" height="584" alt="Image" src="https://github.com/user-attachments/assets/2a2a312e-b053-4b28-b57a-df5dd2ff4990" />

在训练过程中，我们需要通过此变换反向传播损失 ℓ 的梯度，以及计算相对于 BN 变换参数的梯度。我们使用链式法则，如下所示（在简化之前）：
<img width="693" height="385" alt="Image" src="https://github.com/user-attachments/assets/ab040005-be88-4242-8547-834edcdcdd71" />
因此，BN 变换是一个可微变换，它将归一化激活引入网络。这确保了随着模型的训练，层可以继续在表现出较少内部协变量偏移的输入分布上进行学习，从而加速训练。此外，应用于这些归一化激活的学习仿射变换允许 BN 变换表示恒等变换，并保留了网络容量。

训练BN网络
<img width="489" height="677" alt="Image" src="https://github.com/user-attachments/assets/277fcbff-5ad1-4269-b0d3-03815c5e1969" />

在传统的深度网络中，learning rate 过高可能会导致梯度爆炸或消失，以及卡在较差的局部最小值。Batch Normalization 有助于解决这些问题。通过在整个网络中归一化激活，它可以防止参数的小变化放大到激活和梯度中的较大且次优的变化；例如，它可以防止训练卡在非线性函数的饱和区域。Batch Normalization 还使训练对参数规模更具弹性。通常，较大的 learning rate 可能会增加层参数的规模，这然后会放大反向传播过程中的梯度，并导致模型爆炸。然而，使用 Batch Normalization，通过层的反向传播不受其参数规模的影响。


**加速 BN 网络**

仅仅将批量归一化添加到网络中并不能充分利用我们的方法。为此，我们进一步更改了网络及其训练参数，如下所示：
增加学习率。在批量归一化模型中，我们能够实现更高的学习率带来的训练速度提升，而没有任何不良影响（3.3 节）。
移除 Dropout。如 3.4 节所述，批量归一化实现了与 Dropout 相同的一些目标。从修改后的 BN-Inception 中移除 Dropout 可以加快训练速度，而不会增加过拟合。
减少 L2 权重正则化。虽然 Inception 中使用 L2 损失来控制模型参数的过拟合，但在修改后的 BN-Inception 中，此损失的权重减少了 5 倍。我们发现这提高了保留的验证数据上的准确性。
加速学习率衰减。在训练 Inception 时，学习率以指数方式衰减。由于我们的网络训练得比 Inception 快，因此我们更快地将学习率降低 6 倍。
移除局部响应归一化。虽然 Inception 和其他网络（Srivastava et al., 2014）从中受益，但我们发现使用批量归一化时它不是必需的。
更彻底地打乱训练示例。我们启用了训练数据的片内打乱，这防止了相同的示例总是出现在同一个 mini-batch 中。这导致验证准确性提高了约 1%，这与将批量归一化视为正则化器的观点一致（3.4 节）：当我们的方法每次看到示例时都以不同的方式影响示例时，它应该最有益。
减少光度失真。由于批量归一化网络训练得更快，并且观察到每个训练示例的次数更少，因此我们让训练器专注于更多“真实”的图像，方法是减少失真。